<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="Peng." />
    
    <title>Peng's Blog</title>
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1">
    <link href="/atom.xml" rel="alternate" title="Peng's Blog" type="application/atom+xml" />
    <link rel="stylesheet" href="/media/css/style.css">
    <link rel="stylesheet" href="/media/css/github.css">
    <link rel="stylesheet" href="/media/css/fontawesome.css">
    <script src="/media/js/jquery-1.7.1.min.js" type="text/javascript" charset="utf-8"></script> 
    <script type="text/javascript" src="/media/js/highlight.pack.js"></script>
    <script type="text/javascript">
      hljs.initHighlightingOnLoad();
    </script>
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?557edaa583d806553960932bb36729ef";
  var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
})();
</script>

  </head>
  <body>
      <div id="main" role="main">
        <header>
          <div id="header">
            <h1><a title="Peng's Blog" class="" href="/">Peng's Blog</a></h1>
          </div>
          <nav>
            
            <span><a title="Archive" href="/archive.html"><i class="fa fa-list-ul"></i></a></span>
            
            <span><a title="Tags" href="/tags.html"><i class="fa fa-tags"></i></a></span>
            
            <span><a title="About" href="/about.html"><i class="fa fa-user"></i></a></span>
            
          </nav>
        </header>
        <div id="content">
        <div>
  <ul class="listing">
  
  <article class="content">
    <section class="title">
      <h2><a href="/2014/07/19/es6-generator.html">ES6 的 Generator</a></h2>
    </section>
    <section class="meta">
    <span class="time">
      <time datetime="2014-07-19">2014-07-19</time>
    </span>
    
    <span class="tags">
      
      <a href="/tags.html#javascript" title="javascript">#javascript</a>
      
      <a href="/tags.html#nodejs" title="nodejs">#nodejs</a>
      
    </span>
    
    </section>
    <section class="post">
    <p>Generator 是ECMAScript Harmony (ES6) 引入的新特性，通过该特性可以改变异步代码结构，提高代码的可读性。</p>

<p>创建Generator函数</p>

<pre><code>function* Demo () {     // function后面带上*号
    yield "hello";      // yield中断函数执行并返回值
    yield "world";
    return "!";
}
var demo = Demo();              // 需要实例化
console.log (demo.next());      // { value: 'hello', done: false }
console.log (demo.next());      // { value: 'world', done: false }
console.log (demo.next());      // { value: '!', done: true }
</code></pre>

<p>可以看出， 通过yield关键字，可以中断函数的执行，并返回一个对象。<code>{ value: 'hello', done: false}</code> 其中done字段表示函数是否执行完毕。每次调用next方法就可以继续执行yield下面的代码。</p>

<p>再看一个复杂一点的例子：</p>

<pre><code>function* Demo (num) {
    var result = num;
    var base = 0;
    base = yield result;        // result = 5

    console.log (base);         //2. 输出2， base的值等于第二次next调用的参数
    result *= base;             // result = 5 * 2
    base = yield result;

    console.log (base);         //4. 输出3，base的值等于第三次next调用的参数
    result *= base;             // result = 10 * 3
    return result;
}

var demo = Demo(5);
console.log (demo.next(1));     // 1. 输出 { value: 5, done: false }
console.log (demo.next(2));     // 3. 输出 { value: 10, done: false }
console.log (demo.next(3));     // 5. 输出 { value: 30, done: true }

/* 输出依次是：
{ value: 5, done: false }
2
{ value: 10, done: false }
3
{ value: 30, done: true }
*/
</code></pre>

<p>从上述例子可以得出以下结论：</p>

<ol>
<li><p> <strong>Generator函数同样可以传递参数。</strong></p></li>
<li><p> <strong>yield表达式的值是等于后一次调用next方法传入的参数值。（可以理解为：执行表达式<code>yield result</code>后，函数立刻中断并返回第一次next()的结果， 当第二次调用next的时候，函数继续执行并将传入的参数将作为表达式<code>yield result</code>的值。）</strong></p></li>
<li><p> <strong>函数最后<code>return</code>跟<code>yield</code>实现一样的功能，并且返回结果中的<code>done</code>等于<code>true</code>。 （建议尝试把return语句去掉看看会发生什么。）</strong></p></li>
</ol>


<hr />

<p>好，至此已经说完了Generator的使用，那Generator跟异步调用究竟有什么关系？</p>

<p>先说需求：执行异步任务A，B，C，要求执行完A之后得到的结果作为参数传递给任务B，任务B完成之后再将任务B的结果传递给任务C去执行。 这里为了方便，假设A，B，C都是同一类的任务，定义函数如下：</p>

<pre><code>/*
 *  异步任务，传入时间time，callback返回结果time
 */
function somethingAsync (time, callback) {
    setTimeout (function (){
        var err = null;
        console.log ("delay: " + time + "ms");
        if (time &gt;= 10000) {
            err = new Error('timeout');
        }
        callback(err, time);
    }, time);
}
</code></pre>

<p>一般异步的代码是这样(callback hell)：</p>

<pre><code>// task A: 1000ms
somethingAsync(1000, function (err, time) {
    if (err) {
        throw new Error(err);
    }   
    // task B: (1000 + 100)ms
    somethingAsync(time + 100, function (err, time) {
        if (err) {
            throw new Error(err);
        }   
        // task C: (1000 + 100 + 500)ms
        somethingAsync(time + 500, function (err, time) {
            if (err) {
                throw new Error(err);
            }   
            console.log ("done!");
        }); 
    }); 
});
</code></pre>

<p>可以看出，异步代码会出现层层嵌套的结构，假如再多几个任务D，E，F，G，代码会变得难以阅读和维护（现在很多开源模块都能改善这个问题，例如：<a href="https://github.com/caolan/async">async</a>, <a href="https://github.com/kriskowal/q">Q</a>, <a href="https://github.com/JeffreyZhao/wind">wind.js</a>, <a href="https://github.com/teambition/then.js">then.js</a> 等）。引入Generator之后，可以利用yield中断特性改变代码结构：</p>

<pre><code>wrap(function *() {
    var time = 1000;
    time = yield somethingAsyncWrap (time);         // task A: 1000
    time = yield somethingAsyncWrap (time + 100);   // task B: 1000 + 100
    time = yield somethingAsyncWrap (time + 500);   // task C: 1000 + 100 + 500
    return time;;
})(function (err, time){
    if (err) {
        console.error (err);
    } else {
        console.log ("done! time: " + time);    // done!
    }   
});
</code></pre>

<p>以上是改造完后的逻辑代码，通过wrap函数，消除了层层嵌套的callback结构，方便阅读以及维护。</p>

<p>以下是wrap函数的粗略实现：</p>

<pre><code>/*
 * 定义wrap函数，利用Generator的特性消除callback嵌套
 */
function wrap (Gen) {
    var gen = new Gen();

    // 返回一个函数，该函数传入callback，当最后一个异步操作完成后就会触发该callback。
    return function (callback) {
        var next = function (result) {
            var fn = result.value;
            if (result.done) {  // 已经完成所有yield中断，最后一个异步任务完成
                callback (null, result.value);
            }   
            else {
                // 执行异步任务
                fn (function (err, val) {
                    if (err) {
                        callback (err);
                    }   
                    else {
                        // 完成后以返回结果作为参数调用下一次yield（下一个任务）
                        result = gen.next (val);
                        // 递归实现
                        next (result);
                    }   
                }); 
            }   
        };  
        next (gen.next());
    };  
} 
</code></pre>

<p>除此之外，需要对原本异步函数进行封装，以便适应wrap的调用。（这是这种方法的一个缺点： 需要对每个异步函数封装）</p>

<pre><code>/* 封装原本的异步函数使其适应wrap函数的调用。*/
function somethingAsyncWrap (time) {
    return function (callback) {
        somethingAsync (time, callback);
    }   
}
</code></pre>

<p>到此为止， 我们实现了利用Generator的特性对异步代码结构进行优化。</p>

<p>其中，上述的<code>wrap</code>函数其实是<a href="https://github.com/visionmedia">TJ大神</a>开源项目<a href="https://github.com/visionmedia/co">co</a>的粗略版，建议大家去阅读一下大神的源码。 另外，TJ大神还有<a href="https://github.com/visionmedia/node-thunkify">thunkify</a>用于封装异步函数。
co是新一代框架<a href="https://github.com/koajs/koa">koa</a>的核心，建议node.js的朋友去了解一下。
<a href="https://github.com/visionmedia/co#example">co example</a></p>

<hr />

<p>P.S: 以上代码基于Node v0.11.13 harmony模式运行。</p>

<pre><code>$ node --harmony
</code></pre>

<p>只有v0.11.*的版本才支持Generator的特性。</p>

    </section>
    </article>
  
  </ul>
  <div class="divider"></div>
  <ul class="listing main-listing">
    <li class="listing-seperator">Happend earlier this year</i>
  
  
    
    
    <li class="listing-item">
      <time datetime="2014-07-12">2014-07-12</time>
      <a href="/2014/07/12/javascript-prototype-protot.html" title="简析Javascript的prototype和__proto__">简析Javascript的prototype和__proto__</a>
    </li>
  
    
    
    <li class="listing-item">
      <time datetime="2014-07-06">2014-07-06</time>
      <a href="/2014/07/06/mongodb-databases-repair.html" title="修复MongoDB Replica Set数据库">修复MongoDB Replica Set数据库</a>
    </li>
  
    
    
    <li class="listing-item">
      <time datetime="2014-07-02">2014-07-02</time>
      <a href="/2014/07/02/nginx-upgrade-on-fly.html" title="Nginx 平滑升级">Nginx 平滑升级</a>
    </li>
  
    
    
    <li class="listing-item">
      <time datetime="2014-06-30">2014-06-30</time>
      <a href="/2014/06/30/github-blog-jekyll.html" title="在Github上部署自己的博客">在Github上部署自己的博客</a>
    </li>
  
    
    
    <li class="listing-item">
      <time datetime="2014-06-28">2014-06-28</time>
      <a href="/2014/06/28/from-now-on.html" title="从这一刻开始">从这一刻开始</a>
    </li>
  
    <li class="listing-seperator"><a href="/archive.html">Long long ago</a></li>
  </ul>
</div>


        </div>
        <footer>
          <div>
            
            &copy; 2014 ~ 2014 Peng. | powered by jekyll | themed by <a href="http://lhzhang.com" title="sext vi" target="_blank">sext vi</a> | fork <a href="https://github.com/waynezhang/blog" title="fork me" target="_blank">me</a>
          </div>
        </footer>
      </div> <!-- main -->
  </body>
</html>
